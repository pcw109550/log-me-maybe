import random

from Crypto.Util.number import getPrime
from eth_bloom.bloom import BloomFilter, get_bloom_bits


def num_disjoint_bits(data, bloom_filter):
    return sum(
        (bloom_filter.value & bloom_bits) == 0 for bloom_bits in get_bloom_bits(data)
    )


def num_filled_bits(bloom_filter):
    return "{0:b}".format(bloom_filter.value).count("1")


def get_random_topic(num_bits=24):
    return random.getrandbits(num_bits - 1) + (1 << (num_bits - 1))


def topics_to_calldata(topics, bytes_per_topic=3):
    return b"".join(
        topic.to_bytes(bytes_per_topic, byteorder="little") for topic in topics
    )


def mine_topics(target_bloom_filter_value):
    target_bit_count = "{:b}".format(target_bloom_filter_value).count("1")
    bloom_filter = BloomFilter()
    topics = []
    filled_bits = 0
    required_hits = 3
    while filled_bits < target_bit_count:
        topic = get_random_topic()
        topic_bytes = topic.to_bytes(32, byteorder="little")
        if (
            sum(
                (target_bloom_filter_value & bloom_bits) != 0
                for bloom_bits in get_bloom_bits(topic_bytes)
            )
            != 3
        ):
            continue
        num = num_disjoint_bits(topic_bytes, bloom_filter)
        if num == required_hits:
            bloom_filter.add(topic_bytes)
            filled_bits = num_filled_bits(bloom_filter)
            if filled_bits > target_bit_count - 48:
                required_hits = 2
            if filled_bits == target_bit_count - 1:
                required_hits = 1
            topics.append(topic)
        print(target_bit_count, filled_bits, len(topics))

    # will use log4
    while len(topics) % 4 != 0:
        topic = get_random_topic()
        topic_bytes = topic.to_bytes(32, byteorder="little")
        if (
            sum(
                (target_bloom_filter_value & bloom_bits) != 0
                for bloom_bits in get_bloom_bits(topic_bytes)
            )
            != 3
        ):
            continue
        topics.append(topic)

    assert bloom_filter.value == target_bloom_filter_value
    return topics


if __name__ == "__main__":
    # attacker(contract) address
    address_bytes = bytes.fromhex("dc1907D268C2Bce80254B1A0C1C941b568801F62")
    test_bloom_filter = BloomFilter()
    test_bloom_filter.add(address_bytes)

    while True:
        p = getPrime(1024)
        q = getPrime(1024)
        target_bloom_filter_value = p * q
        assert target_bloom_filter_value <= 2**2048

        if (
            target_bloom_filter_value | test_bloom_filter.value
            == target_bloom_filter_value
        ):
            break

    topics = mine_topics(target_bloom_filter_value)
    print(topics_to_calldata(topics).hex())
    print(p)
